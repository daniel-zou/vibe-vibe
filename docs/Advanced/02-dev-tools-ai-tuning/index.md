---
title: "第二章：开发工具与 AI 调教指南"
---


![02-dev-tools-ai-tuning_index.png](../../public/images/Advanced/02-dev-tools-ai-tuning_index.png)
# 第二章：开发工具与 AI 调教指南





### 模型 vs 工具

环境装好了，你手里握着一份庞大的工具清单，面对 **Deepseek, 豆包, 千问, GLM, MiniMax, GPT, Claude, Gemini** 这些模型，还有 **Cursor, Trae, Windsurf** , **Qoder, Code Buddy** , **Antigravity** 这些编辑器，以及 **Claude Code, CodeX, Qoder CLI, Droid CLI, Warp** 等各种 CLI 命令行工具，你彻底晕了。

你不知道它们之间有什么区别。经过老师傅的介绍，你终于明白了：**模型决定代码能力的速度和上限，工具决定代码实现的方式和效率。** 最终，你在老师傅的介绍下选择了适合自己的开发组合。

说起模型，你可能会觉得既然 Claude 4.5 Opus 能力最强，就全部用它。但老师傅提醒你：**国产模型便宜且访问快，并拥有不俗的表现，Claude 贵**且存在网络环境问题（即使有很多中转站）。以 GLM 4.7 为例，每次 prompt 预计可调用模型 15-20 次，每月总计可用总量高达几十亿到数百亿 tokens，折算下来仅为 API 价格的 0.1 折，极具性价比。这个成本意识在 AI 原生开发中非常重要，否则规模上来后账单会让你震惊。



### 版本控制 Git 

看着你跃跃欲试准备让 AI 大改代码，老师傅突然按住了你的手，问了一个问题："**如果 AI 这一次改错了，把你本来能跑的代码改崩了，甚至把你昨天的功能覆盖了，你怎么办？**" 你意识到，如果没有版本控制，错误的修改可能导致之前的成果无法恢复。

老师傅告诉你，AI 编程非常激进，它可能为了修一个 Bug 而破坏三个旧功能。所以，在开始大规模开发之前，你必须配置好 **Git**。在这一阶段，你不需要懂什么复杂的"远程仓库"或"分支策略"，你只需要利用它建立高频的**本地版本记录**。

既然代码是 AI 写的，那么维护版本这种重复性工作也应该全权交给 AI，完全不需要你操心。老师傅传授了一句**写在 AI 规则里的指令**，让版本管理成为自动化的常规流程：

> **"每当你完成一个独立功能的开发，或修复完一个 Bug 并验证通过后，请自动运行 git commit 提交代码，并生成一句简洁的中文 commit message。"**

从此，你的开发流程变成了：AI 写完登录功能 → 自动存档；AI 写完首页 → 自动存档。一旦 AI 在写"个人中心"时把整个项目搞崩了，你不需要慌张，让 AI 帮你回退到上一个版本即可。这能确保在代码出现问题时迅速恢复，保障开发进度。

老师傅继续说："但用 Git 有一个大坑：如果不配置 `.gitignore`，很容易把敏感文件（如环境变量、密码）提交到云端仓库，造成严重的安全问题。**gitignore** 文件就是告诉 Git 哪些文件不应该被提交。**【详见第6章】** 详细配置。"



### 提示词工程

你跃跃欲试，想了一个 Demo 发过去，发现 AI 给的方案五花八门，中途有时候想按照自己的心意修改，结果改了这里坏了那里，引发连锁问题。

你觉得这三招已经很厉害了，基本能解决大部分问题。但你还是遇到了一些困惑：有时候 AI 还是会一本正经地胡说八道，给你编造根本不存在的接口；有时候你的提示词写得老长，效果反而不如简单几句；你甚至不知道什么时候、怎么描述任务。

老师傅告诉你，真正的高手不是靠配置，而是靠说话的艺术。这背后有一套提示词工程的心法。

老师傅让你做一个思想实验：想象你雇了一个**临时工**，这个人很能干，对你的行业了解很多，但不知道你公司的名字，也不知道你项目的具体背景。他第一天上班，直接对你说："嘿，我被告知有工作让我做，告诉我详情。"你会对他说什么？你会说"你是一个正在做图表的高中老师"吗？不会，你会直接告诉他任务："我们想让你检测图表的好坏。好的图表不需要完美，但要有坐标轴标记，大概高中水平就行。"**AI 就是这个临时工**。你不需要玩角色扮演，只需要清晰地传达任务上下文。

还有个问题：你遇到过 AI 不知道答案，但强行编造一个的情况。老师说，这是因为你没给 AI 一个"出口"。你应该告诉它："如果不确定，就明确说出来，等待我的确认，而不是强行编造。"

你还可以用类比帮助 AI 理解复杂概念、用录音转录的方式写提示词、让 AI 帮你改进提示词，甚至——知道什么时候该停下来，换个思路或者换个模型。

掌握这些心法后，你发现 AI 的输出质量显著提升。你知道什么时候该直接描述任务，什么时候该用类比，最重要的是——你知道 AI 的边界在哪里，不再让它做它不擅长的事。你的提示词越来越简洁，但效果却越来越好。





### 需求梳理

老师傅教你一个关键技巧：**让 AI 反复提问，直到问无可问**。你发现很多时候自己以为想清楚了需求，但 AI 写出来后发现不是那么回事。老师说，这是因为你的需求还有很多模糊地带。你应该在开始开发前，明确告诉 AI："**请反复问我问题，直到你完全理解我的需求为止。**" 这个过程看似浪费时间，实则是帮你理清思路——AI 问的每一个问题，都是你需求中的盲点。当 AI 问无可问时，你的需求也就真正清晰了。

你开始意识到需要统一标准。在老师傅的引导下，知道了要写 **PRD（产品需求文档，见下一节）**，并明白了"单一事实来源"的重要性：**不要让 AI 猜你想做什么，而是用文档告诉它必须做什么。**





## 配置技巧

除了选对工具，老师傅还传授了你三招让 AI 更加好用的技巧，解决了 AI 记性差、瞎胡写的问题：



### 项目规则

你之前总抱怨 AI 忘记你用的是 shadcn 还是 Tailwind，或者总是写错 TypeScript 类型。老师傅让你在项目根目录新建一个类似 **`.iderules`**（不同的工具名字可能不同）文件。你在里面写上："禁止使用 `any` 类型"、"强制使用 `pnpm`"、"修改之前必须考虑项目整体结构"。从此以后，AI 每次写代码前都会先参考这份**项目规范**，生成的代码质量瞬间提升，再也不胡乱引入你没安装的库了。

### 专属技能

针对 **Claude Code** 这样的 CLI 工具，老师傅教你创建或者安装 **Skills**。在这里，你可以用自然语言定义专属的指令，比如"每当我说'分析数据'时，就自动运行 `node scripts/analyze.js` 并总结结果"。这相当于为 AI 定义了一套标准作业流程，让它学会了你专属的工作流。

### 赋予能力

老师傅提到了 **MCP (Model Context Protocol)**和**插件 Plugins** 。以前你只能问 AI 问题，现在通过配置 MCP和插件，你可以让 AI **连接 GitHub 仓库**看代码，**连接 PostgreSQL 数据库**查数据，读取 **Figma** 设计稿，甚至接入 **Stripe** 支付。你不需要懂底层原理，只需要简单配置，你的 AI 就拥有了操作外部工具能力。

掌握这三招，你的 AI 已经变得聪明多了。但老师傅告诉你，这只是开始。还有更多让 AI 更懂你项目的方式，比如创建 **CLAUDE.md** 文件作为项目的"说明书"，配置 **Hooks** 让 AI 自动执行重复任务，或者创建专门的 **Subagents** 处理特定类型的工作。这些高级功能我们会在后续章节中逐步探索，现在先打好基础。





### 标准工作流

你庆幸自己选择了 AI IDE 或 CLI 工具，而不是在网页版对话框里手动复制粘贴。你发现，工具能直接读取你的项目上下文，生成的修改建议可以直接通过点击按钮无缝合并到代码中。这意味着你不会遇到那些手动复制粘贴时常犯的错误——比如不小心把 AI 偷懒生成的 `// ... rest of code` 注释也复制进文件导致程序崩溃。此外，你还发现可以给工具更高的权限，甚至某些工具还可以把消息推送到你的手机上，这样他们在执行大部分命令时都不需要你的批准，实现了高度的自动化，你可以趁机干自己的事情。

你深刻意识到：**Vibecoding 的核心不仅是 Prompt（提示词），更是 Workflow（工具流）。**

老师傅接着说，既然是讲工作流，那不能不提 Claude Code 的一些成熟模式。你之前是想到哪里做到哪里，让 AI 直接开写，但这样往往会导致返工。

推荐的标准流程是：**先探索项目结构，再规划实现步骤，然后编码，最后提交**。这听起来像废话，但你照着做了几次，发现效率确实提高不少——因为你不会写到一半才发现"哎呀，原来这个文件已经写过了"。

除了标准流程，还有一些实用技巧：指令要具体（"为登录页面添加测试"不如"为 app/login/page.tsx [手动拖入或者粘贴文件路径] 编写 Playwright 测试用例，覆盖密码错误、账号不存在的边缘情况"）、给 AI 看截图或设计图、明确告诉它要查看哪些文件。这些细节看似小事，但能显著减少来回沟通的次数。

你学会了在正确的时机使用正确的工作流，开发效率显著提升，更重要的是，你不再害怕大规模修改代码。

至于测试驱动开发（TDD）这类更专业的工作流，我们会在测试章节中深入讲解。



### 调试心法

在结束序言前，老师傅还传授了一套调试的心法。他说："有了AI，遇到错误不要慌。但要让AI帮你，你得学会正确的求助方式。"

他教你两个关键点：

**第一，提供完整报错日志**。新手看到满屏红色报错往往害怕，只复制最后一行，或者只说"报错了"。但AI就像医生，需要看到完整的症状才能准确诊断。你应该把那些**看起来最长、最复杂的红色错误信息——原封不动地全选、复制、发送给AI**。只有提供了完整的上下文，AI才能精准定位是哪一行代码出了问题，而不是在那儿盲目猜测。

**第二，循环修复模式**。如果AI第一次没修好，不要放弃。描述你尝试后的结果："我按你的方法改了，但现在出现了新的错误..."，让AI持续尝试。大多数Bug都需要2-3轮迭代才能解决。现在的AI工具甚至能直接读取你的终端报错，你只需要下令"帮我构建项目，检查所有报错并自动修复"，AI就会自动循环"运行-报错-修复"的过程，直到问题解决。

掌握了这套心法，你发现调试不再是恐惧时刻，而是与AI协作解决问题的过程。你不再害怕报错，因为你知道只要提供完整信息，AI总能帮你找到出路。



## 拓展知识 🟢

老师傅告诉你，以上是AI编程的核心工作流。当你熟练掌握后，还可以探索更高级的能力：

**MCP (Model Context Protocol)**：让AI连接外部世界的桥梁。通过MCP，AI可以读取数据库、查看GitHub仓库、调用API，甚至操作文件系统——相当于给AI装上了"手脚"。

**多代理系统**：复杂项目可以让多个AI协同工作。一个AI写代码，另一个AI审查；一个写测试，另一个写文档。它们可以并行处理（提高效率）或串行处理（保证质量），还能集成到CI/CD流程中实现自动化。

**Hooks安全防护**：配置Hooks作为"守门员"，拦截`rm -rf`等危险命令，禁止写入`.env`敏感文件，为AI操作加上安全锁。

**沙盒模式**：当需要完全隔离环境时，用`--sandbox`标志启动。沙盒是进程级隔离，限制AI只能访问指定目录和资源，适合运行不受信代码或CI/CD构建。

这些拓展知识会在后续章节中深入讲解。现在先掌握核心工作流，一步一个脚印。
